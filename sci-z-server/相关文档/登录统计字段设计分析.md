# sys_user 表中登录统计字段设计分析

## 一、问题概述

**问题**：`sys_user` 表中的三个字段（`login_count`、`last_login_time`、`last_login_ip`）是否冗余？是否应该移到 `sys_login_log` 表中？

## 二、表结构对比分析

### 2.1 sys_user 表（用户主表）

| 字段              | 类型        | 说明         | 用途                       |
| ----------------- | ----------- | ------------ | -------------------------- |
| `login_count`     | INT         | 登录次数     | 累计成功登录次数           |
| `last_login_time` | TIMESTAMP   | 最后登录时间 | 最近一次成功登录时间       |
| `last_login_ip`   | VARCHAR(50) | 最后登录 IP  | 最近一次成功登录的 IP 地址 |

### 2.2 sys_login_log 表（登录日志表）

| 字段             | 类型         | 说明       | 用途                       |
| ---------------- | ------------ | ---------- | -------------------------- |
| `user_id`        | BIGINT       | 用户 ID    | 关联用户                   |
| `username`       | VARCHAR(50)  | 用户名     | 登录时的用户名（历史快照） |
| `login_ip`       | VARCHAR(50)  | 登录 IP    | 每次登录的 IP 地址         |
| `login_location` | VARCHAR(100) | 登录地点   | 每次登录的地点             |
| `login_time`     | TIMESTAMP    | 登录时间   | 每次登录的时间             |
| `status`         | SMALLINT     | 登录状态   | 1=成功，0=失败             |
| `browser`        | VARCHAR(50)  | 浏览器信息 | 每次登录的浏览器           |
| `os`             | VARCHAR(50)  | 操作系统   | 每次登录的操作系统         |

## 三、详细分析

### 3.1 数据冗余性分析

**从数据库规范化角度：**

这三个字段在技术上**可以**从 `sys_login_log` 表中推导出来：

```sql
-- 理论上可以从日志表查询获取
SELECT
    COUNT(*) as login_count,
    MAX(login_time) as last_login_time,
    (SELECT login_ip FROM sys_login_log
     WHERE user_id = ? AND status = 1
     ORDER BY login_time DESC LIMIT 1) as last_login_ip
FROM sys_login_log
WHERE user_id = ? AND status = 1;
```

**结论：** 从严格的数据规范化角度，这些字段确实存在**一定程度的冗余**。

### 3.2 实际业务场景分析

#### 场景 1：用户信息展示（高频访问）

**需求**：用户个人中心、管理员查看用户列表时，需要显示：

- 该用户总共登录了多少次
- 最后登录时间
- 最后登录 IP

**如果从 sys_login_log 查询：**

```sql
-- 需要查询日志表（可能包含大量数据）
SELECT COUNT(*) FROM sys_login_log WHERE user_id = ? AND status = 1;
SELECT MAX(login_time) FROM sys_login_log WHERE user_id = ? AND status = 1;
-- 需要子查询获取最后登录的IP
```

**如果从 sys_user 查询：**

```sql
-- 直接查询用户表（单表查询，性能极佳）
SELECT login_count, last_login_time, last_login_ip FROM sys_user WHERE id = ?;
```

**性能对比：**

- `sys_user` 表：**O(1) 时间复杂度**，单表查询，数据量小（用户数）
- `sys_login_log` 表：**O(n) 时间复杂度**，需要聚合查询，数据量大（登录记录数）

#### 场景 2：用户列表查询（分页）

**需求**：管理员查看用户列表，需要显示每个用户的最后登录信息

**如果从 sys_login_log 查询：**

```sql
-- 需要为每个用户执行子查询，性能极差
SELECT u.*,
    (SELECT COUNT(*) FROM sys_login_log WHERE user_id = u.id AND status = 1) as login_count,
    (SELECT MAX(login_time) FROM sys_login_log WHERE user_id = u.id AND status = 1) as last_login_time,
    (SELECT login_ip FROM sys_login_log WHERE user_id = u.id AND status = 1
     ORDER BY login_time DESC LIMIT 1) as last_login_ip
FROM sys_user u
LIMIT 10 OFFSET 0;
```

**如果从 sys_user 查询：**

```sql
-- 直接查询，无需关联
SELECT id, username, real_name, login_count, last_login_time, last_login_ip
FROM sys_user
LIMIT 10 OFFSET 0;
```

**性能对比：**

- `sys_user` 表：**单表查询，性能优秀**
- `sys_login_log` 表：**N+1 查询问题，性能极差**

#### 场景 3：用户活跃度统计

**需求**：统计活跃用户（最近 30 天登录过的用户）

**如果从 sys_login_log 查询：**

```sql
-- 需要 DISTINCT 和日期过滤
SELECT DISTINCT user_id FROM sys_login_log
WHERE login_time >= NOW() - INTERVAL '30 days' AND status = 1;
```

**如果从 sys_user 查询：**

```sql
-- 直接过滤，性能优秀
SELECT id, username FROM sys_user
WHERE last_login_time >= NOW() - INTERVAL '30 days';
```

**性能对比：**

- `sys_user` 表：**索引查询，性能优秀**
- `sys_login_log` 表：**需要 DISTINCT，可能产生大量数据扫描**

### 3.3 设计原则分析

#### 3.3.1 数据一致性风险

**风险：** 如果 `sys_user` 中的统计字段与 `sys_login_log` 中的数据不一致，会导致数据准确性问题。

**解决方案：**

1. **事务保证**：登录成功后，在同一事务中：
   - 插入登录日志到 `sys_login_log`
   - 更新 `sys_user` 的统计字段
2. **补偿机制**：定期校验和修复（如定时任务）
3. **事件驱动**：使用事件机制，确保数据同步

#### 3.3.2 存储空间考虑

**存储成本：**

- `login_count`: INT (4 字节)
- `last_login_time`: TIMESTAMP (8 字节)
- `last_login_ip`: VARCHAR(50) (最多 50 字节)

**总计：** 每个用户约 62 字节

**假设场景：**

- 10 万用户：约 6.2 MB
- 100 万用户：约 62 MB

**结论：** 存储成本**几乎可以忽略不计**，但带来的性能提升是巨大的。

### 3.4 实际案例参考

**业界最佳实践：**

大多数成熟的系统都采用类似的设计：

1. **GitHub**：用户表中有 `last_login_at` 字段
2. **GitLab**：用户表中有 `last_activity_on` 字段
3. **Discourse**：用户表中有 `last_seen_at` 字段
4. **Rails 应用**：通常使用 `last_sign_in_at` 和 `sign_in_count` 字段

**设计模式：**
这是典型的**反规范化设计（Denormalization）**，用于**性能优化**。

## 四、结论与建议

### 4.1 结论

**这三个字段不应该移到 `sys_login_log` 表中，应该保留在 `sys_user` 表中。**

### 4.2 理由

1. **性能优势明显**

   - 查询性能：O(1) vs O(n)
   - 减少数据库负载：避免频繁的聚合查询
   - 提升用户体验：响应速度更快

2. **业务场景需求**

   - 用户信息展示：高频访问场景
   - 用户列表查询：分页场景
   - 活跃度统计：数据分析场景

3. **存储成本极低**

   - 每个用户仅增加约 62 字节
   - 相对于性能提升，成本可以忽略

4. **符合业界最佳实践**
   - 反规范化设计是常见的性能优化手段
   - 主流系统都采用类似设计

### 4.3 建议

#### 4.3.1 数据一致性保证

**推荐实现方式：**

```java
@Service
@RequiredArgsConstructor
public class LoginLogService {

    private final SysUserRepository userRepository;
    private final SysLoginLogRepository loginLogRepository;

    /**
     * 记录登录日志并更新用户统计
     *
     * @param event 登录事件
     */
    @Transactional
    public void recordLoginAndUpdateStats(LoginLoggedEvent event) {
        // 1. 插入登录日志
        SysLoginLog log = new SysLoginLog();
        log.setUserId(event.getUserId());
        log.setUsername(event.getUsername());
        log.setLoginIp(event.getLoginIp());
        log.setLoginTime(LocalDateTime.now());
        log.setStatus(event.getStatus());
        log.setMessage(event.getMessage());
        // ... 其他字段
        loginLogRepository.save(log);

        // 2. 更新用户统计（在同一事务中）
        if (event.getStatus() == 1) { // 仅成功登录更新
            SysUser user = userRepository.findById(event.getUserId());
            if (user != null) {
                user.setLoginCount(user.getLoginCount() + 1);
                user.setLastLoginTime(LocalDateTime.now());
                user.setLastLoginIp(event.getLoginIp());
                userRepository.updateById(user);
            }
        }
    }
}
```

#### 4.3.2 数据校验和修复

**定期校验任务：**

```java
@Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
public void validateAndFixLoginStats() {
    // 校验 sys_user 中的统计字段与 sys_login_log 是否一致
    // 如果不一致，进行修复
}
```

#### 4.3.3 索引优化

**建议索引：**

```sql
-- sys_user 表：用于活跃用户查询
CREATE INDEX IF NOT EXISTS idx_sys_user_last_login_time
ON sys_user(last_login_time) WHERE is_deleted = 0;

-- sys_login_log 表：用于日志查询
CREATE INDEX IF NOT EXISTS idx_sys_login_log_user_time
ON sys_login_log(user_id, login_time DESC) WHERE status = 1;
```

## 五、两个表的使用场景区分

### 5.1 查询场景对比

#### 场景 A：登录日志列表查询（仅查询 `sys_login_log`）

**页面示例**：用户中心 → 安全设置 → 登录日志

**需求**：显示用户的详细登录历史记录，包括每次登录的时间、IP、地点、浏览器、操作系统、状态等。

**查询方式**：

```sql
-- ✅ 只需要查询 sys_login_log 表
SELECT
    login_time AS "登录时间",
    login_ip AS "登录IP",
    login_location AS "登录地点",
    browser AS "浏览器",
    os AS "操作系统",
    CASE
        WHEN status = 1 THEN '登录成功'
        ELSE '异常登录'
    END AS "登录状态"
FROM sys_login_log
WHERE user_id = ?
  AND login_time >= ?  -- 开始日期
  AND login_time <= ?  -- 结束日期
ORDER BY login_time DESC
LIMIT ? OFFSET ?;
```

**Java 实现示例**：

```java
@RestController
@RequestMapping("/api/user")
public class UserSecurityController {

    @GetMapping("/login-logs")
    public Result<PageResult<LoginLogVO>> getLoginLogs(
            @RequestParam(required = false) String startDate,
            @RequestParam(required = false) String endDate,
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "10") int size) {

        Long currentUserId = getCurrentUserId();

        // ✅ 只查询 sys_login_log 表
        LambdaQueryWrapper<SysLoginLog> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(SysLoginLog::getUserId, currentUserId)
               .eq(SysLoginLog::getIsDeleted, 0);

        if (StringUtils.hasText(startDate)) {
            wrapper.ge(SysLoginLog::getLoginTime, startDate);
        }
        if (StringUtils.hasText(endDate)) {
            wrapper.le(SysLoginLog::getLoginTime, endDate);
        }

        wrapper.orderByDesc(SysLoginLog::getLoginTime);

        Page<SysLoginLog> logPage = new Page<>(page, size);
        Page<SysLoginLog> result = loginLogMapper.selectPage(logPage, wrapper);

        // 转换为 VO
        List<LoginLogVO> voList = result.getRecords().stream()
            .map(this::convertToVO)
            .collect(Collectors.toList());

        return Result.success(new PageResult<>(voList, result.getTotal()));
    }
}
```

**结论**：✅ **登录日志列表查询只需要查询 `sys_login_log` 表，不需要查询 `sys_user` 表**

#### 场景 B：用户统计信息展示（查询 `sys_user`）

**页面示例 1**：用户个人中心 → 个人信息

**需求**：显示用户的登录统计信息（登录次数、最后登录时间、最后登录 IP）

**查询方式**：

```sql
-- ✅ 查询 sys_user 表，直接获取统计字段
SELECT
    username,
    real_name,
    login_count AS "登录次数",
    last_login_time AS "最后登录时间",
    last_login_ip AS "最后登录IP"
FROM sys_user
WHERE id = ?;
```

**页面示例 2**：系统管理 → 用户管理 → 用户列表

**需求**：管理员查看用户列表，显示每个用户的基本信息和最后登录信息

**查询方式**：

```sql
-- ✅ 查询 sys_user 表，直接获取所有字段包括统计信息
SELECT
    id,
    username,
    real_name,
    email,
    department_id,
    login_count,
    last_login_time,
    last_login_ip,
    status
FROM sys_user
WHERE is_deleted = 0
ORDER BY created_time DESC
LIMIT ? OFFSET ?;
```

**页面示例 3**：统计活跃用户（最近 30 天登录过的用户）

**查询方式**：

```sql
-- ✅ 查询 sys_user 表，利用 last_login_time 字段快速筛选
SELECT id, username, real_name, last_login_time
FROM sys_user
WHERE is_deleted = 0
  AND last_login_time >= NOW() - INTERVAL '30 days'
ORDER BY last_login_time DESC;
```

**结论**：✅ **用户统计信息展示需要查询 `sys_user` 表，利用反规范化字段提升性能**

### 5.2 两个表的使用场景总结

| 场景                           | 使用的表        | 查询方式        | 说明                       |
| ------------------------------ | --------------- | --------------- | -------------------------- |
| **登录日志列表**               | `sys_login_log` | 单表查询        | 显示详细的登录历史记录     |
| **用户个人信息（含统计）**     | `sys_user`      | 单表查询        | 显示用户的登录统计信息     |
| **用户列表（含最后登录信息）** | `sys_user`      | 单表查询        | 显示每个用户的最后登录信息 |
| **活跃用户统计**               | `sys_user`      | 单表查询 + 索引 | 快速筛选活跃用户           |
| **登录次数统计**               | `sys_user`      | 单表查询        | 直接获取 `login_count`     |

### 5.3 关键点总结

1. **登录日志列表**：✅ **只需要查询 `sys_login_log` 表**

   - 展示详细的每次登录记录
   - 包含时间、IP、地点、浏览器、操作系统、状态等详细信息
   - **不需要关联 `sys_user` 表**

2. **用户统计信息**：✅ **需要查询 `sys_user` 表**

   - 显示汇总的登录统计（登录次数、最后登录时间、最后登录 IP）
   - 用于用户列表、用户详情、活跃度统计等场景
   - **利用反规范化字段，性能优秀**

3. **数据一致性**：两个表的数据是**同步更新的**
   - 登录成功后，在同一事务中：
     - 插入记录到 `sys_login_log`（详细日志）
     - 更新 `sys_user` 的统计字段（汇总信息）

## 六、总结

### 6.1 设计原则

1. **性能优先**：高频查询场景优先考虑性能
2. **适度冗余**：以存储换性能是可接受的
3. **数据一致性**：通过事务和校验机制保证一致性
4. **场景分离**：不同场景使用不同的表，各司其职

### 6.2 最终建议

**保留这三个字段在 `sys_user` 表中，并确保：**

1. ✅ 登录成功后，在同一事务中更新统计字段
2. ✅ 建立适当的索引，优化查询性能
3. ✅ 定期校验数据一致性（可选）
4. ✅ 使用事件机制，确保数据同步
5. ✅ **登录日志列表查询只用 `sys_login_log` 表**
6. ✅ **用户统计信息查询使用 `sys_user` 表**

**这种设计是合理的、高效的、符合业界最佳实践的。**
