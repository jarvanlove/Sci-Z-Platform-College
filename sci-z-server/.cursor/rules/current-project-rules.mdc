---
alwaysApply: false
---

# Sci-Z Server 项目开发规则

## 一、DDD 分层架构

**分层结构**:

```
interfaces/          → controller, converter
application/        → service (接口 + impl)
domain/pojo/        → entity, mapper, repository, dto/request|response
infrastructure/      → config, shared, external, common
```

**依赖方向**: `interfaces` → `application` → `domain` ← `infrastructure`

**各层职责**:

- **Controller**: 入参校验(@Valid)、鉴权注解、调用 Service、返回 Result<resp>
- **Converter**: MapStruct 转换，只做 req↔entity↔resp 转换
- **Service**: 事务(@Transactional)、业务编排、发布事件
- **Repository**: 组合 Mapper 实现数据访问，禁止业务逻辑
- **Entity**: 继承 BaseEntity，与表字段一一对应

## 二、命名规范

**文件命名**:

- Entity: `Xxx.java` (如 `SysUser.java`)
- Mapper: `XxxMapper.java`
- Repository: `XxxRepo.java` + `XxxRepoImpl.java`
- Service: `XxxService.java` + `XxxServiceImpl.java`
- Controller: `XxxController.java`
- Converter: `XxxConverter.java`
- Request: `XxxCreateReq.java`, `XxxUpdateReq.java`, `XxxQueryReq.java`
- Response: `XxxResp.java`, `XxxDetailResp.java`, `XxxPageResp.java`
- Event: `XxxCreatedEvent.java`, `XxxUpdatedEvent.java`, `XxxDeletedEvent.java`
- Handler: `XxxEventHandler.java`

**方法命名**:

- Controller: `createXxx`, `updateXxx`, `deleteXxx`, `getXxxDetail`, `listXxx`, `pageXxx`
- Service: `create`, `update`, `deleteById`, `findDetail`, `list`, `page`
- Repository: `save`, `update`, `deleteById`, `findById`, `findByCondition`, `pageByCondition`
- Converter: `toEntity(req)`, `toResp(entity)`, `toRespList(list)`, `updateEntity(@MappingTarget, req)`

**变量命名**:

- 统一使用驼峰命名（camelCase），禁止使用单字母变量名（如 `a`, `b`, `c`）
- 变量名要有意义，能清晰表达其用途
- 局部变量：`userId`, `userName`, `createTime`
- 循环变量：`item`, `user`, `index`（允许简短的循环变量，但要有意义）
- 布尔变量：`isDeleted`, `hasPermission`, `canEdit`
- 集合变量：`userList`, `userIdSet`, `userMap`
- 临时变量：避免使用 `temp`, `tmp`, `data` 等无意义名称，应使用具体含义的名称

## 三、注释模板

**类注释**:

```java
/**
 * 类功能描述
 *
 * @author JiaWen.Wu
 * @className 当前类名
 * @date 中国北京当前时间 (yyyy-MM-dd HH:mm)
 */
```

**注意**: `@date` 字段需要手动填写创建该文件时的北京时间（格式：yyyy-MM-dd HH:mm），不能自动生成。

**方法注释**:

```java
/**
 * 方法是做什么的
 *
 * @param 参数类型 参数描述
 * @return 返回结果
 */
```

**字段注释**:

```java
/**
 * 字段注释
 */
```

## 四、开发规范

**日志**: 统一使用 `String.format("%s", ...)` 占位符

```java
log.info(String.format("创建用户: userId=%s, username=%s", userId, username));
log.error(String.format("创建用户失败: err=%s", e.getMessage()), e);
```

**异常**: 仅抛 `BusinessException(ResultCode.X)`

```java
throw new BusinessException(ResultCode.USER_NOT_FOUND);
throw new BusinessException(ResultCode.USER_NOT_FOUND, "用户不存在: " + userId);
```

**返回**: Controller 返回`Result<T>`，Service 返回领域对象

```java
// Controller
return Result.success(resp);

// Service
public XxxResp create(XxxCreateReq req) { return resp; }
```

**事务**: Service 写操作加`@Transactional(rollbackFor = Exception.class)`

**Java 版本**: 使用 Java 21 语法及新特性处理代码，保证代码的性能和扩展性

- 优先使用 Java 21 新特性：Record、Pattern Matching、Text Blocks、Sealed Classes 等
- 使用 `var` 关键字简化局部变量声明（当类型明显时）
- 使用 Stream API 和 Optional 处理集合和空值
- 使用现代日期时间 API（`java.time` 包）
- 合理使用并发工具类（`CompletableFuture`、`Virtual Thread` 等）
- 避免使用过时的 API 和废弃的方法

## 五、实现顺序

1. Entity → 继承 BaseEntity，与表字段一一对应
2. Mapper → 继承 BaseMapper<Xxx>
3. Repository → 接口+实现(组合 Mapper)
4. DTO → request(CreateReq/UpdateReq/QueryReq) + response(Resp/DetailResp/PageResp)
5. Converter → MapStruct(componentModel="spring")
6. Service → 接口+实现(事务、编排、发布事件)
7. Controller → 入参校验、鉴权、调用 Service、返回 Result
8. Event & Handler → (按需)发布事件、创建 Handler 处理

## 六、代码模板

### Entity

```java
package com.sciz.server.domain.pojo.entity.xxx;

import com.sciz.server.domain.pojo.entity.BaseEntity;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Getter;
import lombok.Setter;

/**
 * Xxx 实体类
 *
 * @author JiaWen.Wu
 * @className Xxx
 * @date 2025-01-XX 14:30
 */
@Getter
@Setter
@TableName("xxx_table")
public class Xxx extends BaseEntity {
    /**
     * 主键ID
     */
    private Long id;
    /**
     * 名称
     */
    private String name;
}
```

### Mapper

```java
package com.sciz.server.domain.pojo.mapper.xxx;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.sciz.server.domain.pojo.entity.xxx.Xxx;

/**
 * Xxx Mapper
 *
 * @author JiaWen.Wu
 * @className XxxMapper
 * @date 2025-01-XX 14:30
 */
public interface XxxMapper extends BaseMapper<Xxx> {
}
```

### Repository 接口

```java
package com.sciz.server.domain.pojo.repository.xxx;

import com.sciz.server.domain.pojo.entity.xxx.Xxx;

/**
 * Xxx 仓储接口
 *
 * @author JiaWen.Wu
 * @className XxxRepo
 * @date 2025-01-XX 14:30
 */
public interface XxxRepo {
    /**
     * 保存
     *
     * @param entity 实体
     * @return 主键ID
     */
    Long save(Xxx entity);

    /**
     * 根据ID查询
     *
     * @param id 主键ID
     * @return 实体
     */
    Xxx findById(Long id);
}
```

### Repository 实现

```java
package com.sciz.server.domain.pojo.repository.xxx.impl;

import com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;
import com.baomidou.mybatisplus.extension.conditions.update.LambdaUpdateChainWrapper;
import com.sciz.server.domain.pojo.entity.xxx.Xxx;
import com.sciz.server.domain.pojo.mapper.xxx.XxxMapper;
import com.sciz.server.domain.pojo.repository.xxx.XxxRepo;
import org.springframework.stereotype.Repository;

/**
 * Xxx 仓储实现
 *
 * @author JiaWen.Wu
 * @className XxxRepoImpl
 * @date 2025-01-XX 14:30
 */
@Repository
public class XxxRepoImpl implements XxxRepo {
    private final XxxMapper mapper;

    public XxxRepoImpl(XxxMapper mapper) {
        this.mapper = mapper;
    }

    @Override
    public Long save(Xxx entity) {
        // 新增：直接使用 mapper.insert 方法
        int rows = mapper.insert(entity);
        return rows > 0 ? entity.getId() : null;
    }

    @Override
    public boolean updateById(Xxx entity) {
        // 更新：使用 mapper.updateById 方法（根据ID更新）
        return mapper.updateById(entity) > 0;
    }

    /**
     * 根据条件更新指定字段
     *
     * @param id 主键ID
     * @param name 名称
     * @return 是否更新成功
     */
    public boolean updateNameById(Long id, String name) {
        // 更新指定字段：使用 LambdaUpdateChainWrapper
        return new LambdaUpdateChainWrapper<>(mapper)
                .eq(Xxx::getId, id)
                .set(Xxx::getName, name)
                .update();
    }

    @Override
    public Xxx findById(Long id) {
        // 查询：使用 LambdaQueryChainWrapper
        return new LambdaQueryChainWrapper<>(mapper)
                .eq(Xxx::getId, id)
                .eq(Xxx::getIsDeleted, 0)
                .one();
    }

    @Override
    public boolean deleteById(Long id) {
        // 软删除（相当于更新）：使用 LambdaUpdateChainWrapper
        return new LambdaUpdateChainWrapper<>(mapper)
                .eq(Xxx::getId, id)
                .set(Xxx::getIsDeleted, 1)
                .update();
    }
}
```

**说明**:

- **查询操作**：使用 `LambdaQueryChainWrapper`，支持链式调用，类型安全
- **新增操作**：直接使用 `mapper.insert(entity)`，简单高效
- **更新操作**：
  - 根据 ID 更新整个实体：使用 `mapper.updateById(entity)`
  - 根据条件更新指定字段：使用 `LambdaUpdateChainWrapper` 的 `.set()` 方法
- **删除操作**：软删除实际上是通过更新 `is_deleted` 字段实现，使用 `LambdaUpdateChainWrapper` 的 `.set()` 方法

### Request DTO

```java
package com.sciz.server.domain.pojo.dto.request.xxx;

import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

/**
 * Xxx 创建请求
 *
 * @author JiaWen.Wu
 * @className XxxCreateReq
 * @date 2025-01-XX 14:30
 */
@Getter
@Setter
public class XxxCreateReq {
    /**
     * 名称
     */
    @NotBlank(message = "名称不能为空")
    private String name;
}
```

### Response DTO

```java
package com.sciz.server.domain.pojo.dto.response.xxx;

import lombok.Getter;
import lombok.Setter;

/**
 * Xxx 响应
 *
 * @author JiaWen.Wu
 * @className XxxResp
 * @date 2025-01-XX 14:30
 */
@Getter
@Setter
public class XxxResp {
    /**
     * 主键ID
     */
    private Long id;
    /**
     * 名称
     */
    private String name;
}
```

### Converter

```java
package com.sciz.server.interfaces.converter;

import com.sciz.server.domain.pojo.dto.request.xxx.XxxCreateReq;
import com.sciz.server.domain.pojo.dto.response.xxx.XxxResp;
import com.sciz.server.domain.pojo.entity.xxx.Xxx;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

/**
 * Xxx 转换器
 *
 * @author JiaWen.Wu
 * @className XxxConverter
 * @date 2025-01-XX 14:30
 */
@Mapper(componentModel = "spring")
public interface XxxConverter {
    /**
     * req → entity
     */
    Xxx toEntity(XxxCreateReq req);

    /**
     * entity → resp
     */
    XxxResp toResp(Xxx entity);
}
```

### Service 接口

```java
package com.sciz.server.application.service.xxx;

import com.sciz.server.domain.pojo.dto.request.xxx.XxxCreateReq;
import com.sciz.server.domain.pojo.dto.response.xxx.XxxResp;

/**
 * Xxx 应用服务接口
 *
 * @author JiaWen.Wu
 * @className XxxService
 * @date 2025-01-XX 14:30
 */
public interface XxxService {
    /**
     * 创建
     *
     * @param req 创建请求
     * @return 响应
     */
    XxxResp create(XxxCreateReq req);
}
```

### Service 实现

```java
package com.sciz.server.application.service.xxx.impl;

import com.sciz.server.application.service.xxx.XxxService;
import com.sciz.server.domain.pojo.dto.request.xxx.XxxCreateReq;
import com.sciz.server.domain.pojo.dto.response.xxx.XxxResp;
import com.sciz.server.domain.pojo.entity.xxx.Xxx;
import com.sciz.server.domain.pojo.repository.xxx.XxxRepo;
import com.sciz.server.infrastructure.shared.event.EventPublisher;
import com.sciz.server.infrastructure.shared.exception.BusinessException;
import com.sciz.server.infrastructure.shared.result.ResultCode;
import com.sciz.server.interfaces.converter.XxxConverter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Xxx 应用服务实现类
 *
 * @author JiaWen.Wu
 * @className XxxServiceImpl
 * @date 2025-01-XX 14:30
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class XxxServiceImpl implements XxxService {
    private final XxxRepo xxxRepo;
    private final XxxConverter xxxConverter;
    private final EventPublisher eventPublisher;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public XxxResp create(XxxCreateReq req) {
        log.info(String.format("创建Xxx: name=%s", req.getName()));

        // 1. 转换为实体
        Xxx entity = xxxConverter.toEntity(req);

        // 2. 保存
        Long id = xxxRepo.save(entity);
        if (id == null) {
            throw new BusinessException(ResultCode.DATABASE_OPERATION_FAILED);
        }

        // 3. 发布事件（按需）
        // XxxCreatedEvent event = new XxxCreatedEvent(id, entity.getName());
        // eventPublisher.publish(event);

        // 4. 转换为响应
        XxxResp resp = xxxConverter.toResp(entity);

        log.info(String.format("创建Xxx成功: id=%s", id));
        return resp;
    }
}
```

### Controller

```java
package com.sciz.server.interfaces.controller;

import com.sciz.server.application.service.xxx.XxxService;
import com.sciz.server.domain.pojo.dto.request.xxx.XxxCreateReq;
import com.sciz.server.domain.pojo.dto.response.xxx.XxxResp;
import com.sciz.server.infrastructure.shared.result.Result;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

/**
 * Xxx 控制器
 *
 * @author JiaWen.Wu
 * @className XxxController
 * @date 2025-01-XX 14:30
 */
@RestController
@RequestMapping("/api/xxx")
@Tag(name = "模块 - Xxx", description = "Xxx 管理")
@RequiredArgsConstructor
public class XxxController {
    private final XxxService xxxService;

    @PostMapping
    @Operation(summary = "创建Xxx", description = "创建Xxx")
    // @SaCheckPermission("api:module:xxx:create")
    public Result<XxxResp> createXxx(@Valid @RequestBody XxxCreateReq req) {
        XxxResp resp = xxxService.create(req);
        return Result.success(resp);
    }
}
```

## 七、事件处理（按需）

### Event

```java
package com.sciz.server.infrastructure.shared.event.xxx;

import com.sciz.server.infrastructure.shared.event.DomainEvent;
import lombok.Getter;
import lombok.Setter;

/**
 * Xxx 创建事件
 *
 * @author JiaWen.Wu
 * @className XxxCreatedEvent
 * @date 2025-01-XX 14:30
 */
@Getter
@Setter
public class XxxCreatedEvent extends DomainEvent {
    private Long xxxId;
    private String name;

    public XxxCreatedEvent(Long xxxId, String name) {
        super();
        this.xxxId = xxxId;
        this.name = name;
    }

    @Override
    public String getAggregateId() {
        return String.valueOf(xxxId);
    }

    @Override
    public String getAggregateType() {
        return "Xxx";
    }
}
```

### Handler

```java
package com.sciz.server.infrastructure.shared.handler.xxx;

import com.sciz.server.infrastructure.shared.event.xxx.XxxCreatedEvent;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

/**
 * Xxx 事件处理器
 *
 * @author JiaWen.Wu
 * @className XxxEventHandler
 * @date 2025-01-XX 14:30
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class XxxEventHandler {
    @EventListener
    @Async
    public void handleXxxCreated(XxxCreatedEvent event) {
        try {
            log.info(String.format("处理Xxx创建事件: xxxId=%s, name=%s", event.getXxxId(), event.getName()));
            // 调用应用服务入库或联动
            log.info(String.format("Xxx创建事件处理完成: xxxId=%s", event.getXxxId()));
        } catch (Exception e) {
            log.error(String.format("Xxx创建事件处理失败: xxxId=%s, err=%s", event.getXxxId(), e.getMessage()), e);
        }
    }
}
```
